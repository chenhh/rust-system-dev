# 非同(異)步程式

## async vs 其它並發模型(concurrent model)

* <mark style="color:red;">OS 執行緒：</mark>最簡單，也無需改變任何程式模型(業務/代碼邏輯)，因此非常適合作為語言的原生並發模型，Rust 原生支援執行緒級的並發編程。但是，這種模型也有缺點，例如執行緒間的同步將變得更加困難，執行緒間的上下文切換損耗較大。<mark style="color:blue;">使用執行緒池在一定程度上可以提升效能，但是對於 IO 密集的場景來說，執行緒池還是不夠</mark>。
* <mark style="color:red;">事件驅動(Event driven)</mark>：事件驅動常常跟回調( Callback )一起使用。這種模型效能相當的好，但最大的問題就是存在回調地獄(callback hell)的風險：非線性的控制流和結果處理導致了數據流向和錯誤傳播變得難以掌控，還會導致代碼可維護性和可讀性的大幅降低，JavaScript 曾經就存在回調地獄。
* <mark style="color:red;">協程(Coroutines)</mark> ：Go 語言的協程設計就非常優秀。協程跟執行緒類似，無需改變程式模型，同時，它也跟 async 類似，可以支援大量的任務並發運行<mark style="color:blue;">。但協程抽象層次過高，導致用戶無法接觸到底層的細節</mark>，這對於系統編程語言和自定義異步運行時是難以接受的。
* <mark style="color:red;">actor 模型</mark>：將所有並發計算分割成一個一個單元，這些單元被稱為 actor ，單元之間通過訊息傳遞的方式進行通訊和數據傳遞，跟分佈式系統的設計理念非常相像。由於 actor 模型跟現實很貼近，因此它相對來說更容易實現，但<mark style="color:blue;">是一旦遇到流控制、失敗重試等場景時，就會變得不太好用</mark> 。
* <mark style="color:red;">async/await</mark>： 該模型效能高，還能支援底層編程，同時又像執行緒和協程那樣無需過多的改變編程模型，但有得必有失，async 模型的問題就是內部實現機制過於復雜，對於用戶來說，理解和使用起來也沒有執行緒和協程簡單。

Rust 經過權衡取捨後，最終選擇了同時提供多執行程和 async：

* 前者通過標准庫實現，當你無需那麼高的並發時，例如需要並行(parallel)計算時，可以選擇它，優點是執行緒內的代碼執行效率更高、實現更直觀更簡單。
* 後者通過語言特性 + 標准庫 + 三方庫的方式實現，在你需要高並發(concurrent)、異步 I/O 時，選擇它就對了。

## async: Rust vs 其它語言

目前已經有諸多語言都通過 async 的方式提供了異步程式設計，但 Rust 在實現上有所區別:

* <mark style="color:red;">Future</mark> 在 Rust 中是惰性的，只有在被輪詢(poll)時才會運行， 因此丟棄一個 future 會阻止它未來再被運行, 你可以將Future理解為一個在未來某個時間點被調度執行的任務。
* <mark style="color:red;">Async 在 Rust 中使用開銷是零</mark>， 意味著只有你能看到的程式碼(自己的程式碼)才有效能損耗，你看不到的(async 內部實現)都沒有效能損耗，例如，你可以無需分配任何堆積記憶體、也無需任何動態分發來使用 async ，這對於熱點路徑的效能有非常大的好處，正是得益於此，Rust 的異步編程效能才會這麼高。
* <mark style="color:red;">Rust 沒有內置異步調用所必須的運行時間</mark>，但是無需擔心，Rust 社區生態中已經提供了非常優異的運行時實現，例如tokio 運行時同時支援單執行緒和多執行緒，這兩者擁有各自的優缺點。

## Rust: async vs 多執行緒

雖然 async 和多執行緒都可以實現並發編程，後者甚至還能通過執行緒池來增強並發能力，但是這兩個方式並不互通，從一個方式切換成另一個需要大量的程式碼重構工作，因此提前為自己的項目選擇適合的並發模型就變得至關重要。

<mark style="color:red;">OS 執行緒非常適合少量任務並發(task concurrent)，因為執行緒的創建和上下文切換是非常昂貴的，甚至於空閒的執行緒都會消耗系統資源</mark>。雖說執行緒池可以有效的降低效能損耗，但是也無法徹底解決問題。當然，執行緒模型也有其優點，例如它不會破壞你的程式碼邏輯和程式模型，你之前的順序程式碼，經過少量修改適配後依然可以在新執行緒中直接運行，同時在某些作業系統中，你還可以改變執行緒的優先級，這對於實現驅動程式或延遲敏感的應用(例如硬實時系統)很有幫助。

<mark style="color:red;">對於長時間運行的 CPU 密集型任務，例如並行計算，使用執行緒將更有優勢</mark>。 這種密集任務往往會讓所在的執行緒持續運行，任何不必要的執行緒切換都會帶來效能損耗，因此高並發反而在此時成為了一種多餘。同時你所創建的執行緒數應該等於 CPU 核心數，充分利用 CPU 的並行能力，甚至還可以將執行緒綁定到 CPU 核心上，進一步減少執行緒上下文切換。

<mark style="color:red;">而高並發更適合 IO 密集型任務，例如 web 服務器、數據庫連接等等網絡服務</mark>，因為這些任務絕大部分時間都處於等待狀態，如果使用多執行緒，那執行緒大量時間會處於無所事事的狀態，再加上執行緒上下文切換的高昂代價，讓多執行緒做 IO 密集任務變成了一件非常奢侈的事。而使用async，既可以有效的降低 CPU 和內存的負擔，又可以讓大量的任務並發的運行，一個任務一旦處於IO或者其他等待(阻塞)狀態，就會被立刻切走並執行另一個任務，而這裡的任務切換的效能開銷要遠遠低於使用多執行緒時的執行緒上下文切換。

事實上，async 底層也是基於執行緒實現，但是它基於執行緒封裝了一個運行時，可以將多個任務對映到少量執行緒上，然後將執行緒切換變成了任務切換，後者僅僅是記憶體中的訪問，因此要高效的多。

<mark style="color:red;">不過async也有其缺點，原因是編譯器會為async函數生成狀態機，然後將整個運行時打包進來，這會造成我們編譯出的二進制可執行檔案體積顯著增大</mark>。

### 使用時機

* 有大量 IO 任務需要並發運行時，選 async 模型。
* 有部分 IO 任務需要並發運行時，選多執行緒，如果想要降低執行緒創建和銷毀的開銷，可以使用執行緒池。
* 有大量 CPU 密集任務需要並行運行時，例如並行計算，選多執行緒模型，且讓執行緒數等於或者稍大於 CPU 核心數。
* 無所謂時，統一選多執行緒。
