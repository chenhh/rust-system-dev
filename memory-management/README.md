# 記憶體管理

## 堆疊與堆積\(stack and heap\)

一個行程在執行的時候，它所佔用的記憶體的虛擬位址空間一般被分割成好幾個區域，我們稱為“段”（Segment）。常見的幾個段如下。

* 程式碼片段 \(code segment\)：編譯後的機器碼存在的區域。一般這個段是唯讀的。
* bss段：存放未初始化的全域變數和靜態變數的區域。
* 資料段 \(data segment\)：存放有初始化的全域變數和靜態變數的區域。
* 函式呼叫堆疊（call stack segment）：存放函數參數、區域變數以及其他函式呼叫相關資訊的區域。
* 堆積（heap）：存放動態分配記憶體的區域。

函式呼叫堆疊（call stack）也可以簡稱為堆疊（stack）。因為函式呼叫堆疊本來就是基於堆疊這樣一個資料結構實現的。它具備“後入先出”（LIFO）的特點。最先進入的資料也是最後出來的資料。

一般來說，CPU有專門的指令可以用於入堆疊\(PUSH\)或者出堆疊\(POP\)的操作。當一個函數被調用時，就會有指令把當前指令的位址壓入堆疊內保存起來，然後跳轉到被調用的函數中執行。函數返回的時候，就會把堆疊裡面先前的指令位址彈出來繼續執行。

![&#x8A18;&#x61B6;&#x9AD4;&#x4E2D;&#x7684;&#x5806;&#x758A;](../.gitbook/assets/stack-min.png)

堆積是為動態分配預留的記憶體空間。和堆疊不一樣，從堆積上分配和重新分配塊沒有固定模式，使用者可以在任何時候分配和釋放它。這樣就使得跟蹤哪部分堆積已經被分配和被釋放變得異常複雜；有許多定制的堆積分配策略用來為不同的使用模式下調整堆的性能。堆積是在記憶體中動態分配的記憶體，是無序的。每個執行緒都有一個堆疊，但是每一個應用程式通常都只有一個堆積。在堆積上的變數必須要手動釋放，不存在作用域的問題。

![&#x8A18;&#x61B6;&#x9AD4;&#x4E2D;&#x7684;&#x5806;&#x7A4D;](../.gitbook/assets/heap-min.png)

一般來說，作業系統提供了在堆積上分配和釋放記憶體的系統調用，但是使用者不是直接使用這個系統調用，而是使用封裝的更好的“記憶體分配器”（Allocator）。比如，在C語言裡面，執行時（runtime）就提供了malloc和free這兩個函數可以管理堆記憶體。

堆積和堆疊之間的區別有：

* 堆疊上保存的區域變數在退出當前作用域的時候會自動釋放；
* 堆積上分配的空間沒有作用域，需要手動釋放；
* 一般堆疊上分配的空間大小是編譯階段就可以確定的（C語言裡面的VLA除外）；
* 堆疊有一個確定的最大長度，超過了這個長度會產生“堆疊溢出”（stack overflow）；
* 堆積的空間一般要更大一些，堆積上的記憶體耗盡了，就會產生“記憶體分配不足”（out of memory）。

{% embed url="https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap" %}

## segment fault

segfault實際上是“segmentation fault”的縮寫形式，可以翻譯為“段錯誤”。

**segfault是這樣形成的：行程空間中的每個段通過硬體MMU映射到真正的物理空間；在這個映射過程中，我們還可以給不同的段設置不同的存取權限**，比如程式碼片段就是只能讀不能寫；

**行程在執行過程中，如果違反了這些許可權，CPU會直接產生一個硬體異常；硬體異常會被作業系統內核處理，一般內核會向對應的行程發送一條信號；如果沒有實現自己特殊的信號處理函數，預設情況下，這個行程會直接非正常退出**；如果作業系統打開了core dump功能，在行程退出的時候作業系統會把它當時的記憶體狀態、暫存器狀態以及各種相關資訊保存到一個檔案中，供用戶以後除錯使用。

在傳統系統級程式設計語言C/C++裡面，製造segfault是很容易的。程式師需要非常小心才能避免這種錯誤，這也是為什麼會有那麼多的程式碼標準來規範程式師的行為。而另外一類程式設計語言規避segfault的辦法是使用自動垃圾回收機制\(garbage collection, GC\)。在這些程式設計語言中，指標的能力被大幅限制，記憶體分配和釋放都在一個執行時環境中被嚴格管理。當然，這麼做也付出了一定的代價。某些應用場景下用這樣的代價換取開發效率和安全性是非常划算的，而在某些應用場景下這樣的代價是不可接受的。

Rust的主要設計目標之一，是在不用自動垃圾回收機制的前提下避免產生segfault。從這個意義上來說，它是獨一無二的。

## 記憶體安全

下面列舉一系列的“記憶體不安全”的例子。以下這些情況，就是Rust想要避免的問題。注意，記憶體洩漏（memory leak）並非記憶體不安全。

* **空指標 \(null pointer\)**：解引用空指標是不安全的。這塊位址空間一般是受保護的，對空指標解引用在大部分平臺上會產生segfault。
* **野指標 \(wild pointer\)**：野指標指的是未初始化的指標。它的值取決於它這個位置以前遺留下來的是什麼值。所以它可能指向任意一個地方。對它解引用，可能會造成segfault，也可能不會，純粹憑運氣。但無論如何，這個行為都不會是你預期內的行為，是一定會產生bug的。
* **懸空指標（dangling pointer）：**懸空指標指的是記憶體空間在被釋放了之後，繼續使用。它跟野指標類似，同樣會讀寫已經不屬於這個指標的內容。·
* **使用未初始化記憶體**：不只是指標類型，任何一種類型不初始化就直接使用都是危險的，造成的後果我們完全無法預測。
* **非法釋放記憶體**：記憶體分配和釋放要配對。如果對同一個指標釋放兩次，會製造出記憶體錯誤。如果指標並不是記憶體分配器返回的值，對其執行釋放操作，也是危險的。
* **緩衝區溢位（buffer overflow）**：指標訪問越界了，結果也是類似於野指標，會讀取或者修改臨近記憶體空間的值，造成危險。
* 執行非法函數指標：如果一個函數指標不是準確地指向一個函數位址，那麼調用這個函數指標會導致一段亂數據被當成指令來執行，是非常危險的。
* **資料競爭（race condition）**：在有併發的場景下，針對同一塊記憶體同時讀寫，且沒有同步措施。

以上這些問題都是極度危險的，而且它們並不一定會在發生的時候就被發現並立即終止。它們不一定會直接觸發core dump，有可能程式一直帶病執行，只是結果一直有bug但卻無法找到原因，因為真正的原因與表現之間沒有任何肉眼可見的關聯關係。它們有可能造成非常隨機的、難以複現和難以除錯的詭異bug，行蹤不定。它們也可能在經過許多步驟之後最終觸發core dump，可惜此時早已不是案發第一現場，修復這種bug的難度極高。

在Rust語境中，還有一些記憶體錯誤是不算在“記憶體安全”範疇內的，比如**記憶體洩漏**以及**記憶體耗盡**。

* 記憶體洩漏顯然是一種bug，但是它不會直接造成非常嚴重的後果，至少比上面列出的那些錯誤危險性要低一些，解決的辦法也是完全不一樣的。
* 同樣，記憶體耗盡也不是事關安全性的問題，出現記憶體耗盡的時候，Rust程式的行為依然是確定性的和可控的（目前版本下，如果記憶體耗盡則發生panic，也有人認為在這種情況發生的時候，應該給個機會由使用者自己處理，這種情況後面應該會有改進）。

另外，panic也不屬於記憶體安全相關的問題。panic和core dump之間有重要區別。

* panic是發生不可修復錯誤後，程式主動執行的一種錯誤處理機制；
* 而core dump則是程式失控之後，觸發了作業系統的保護機制而被動退出的。

發生panic的時候，此處就是確定性的第一現場，我們可以根據call stack資訊很快找到事發地點，然後修復。panic是防止更嚴重記憶體安全錯誤的重要機制。

