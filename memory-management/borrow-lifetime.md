# 借用和生命週期

## 生命週期\(lifetime\)

一個變數的生命週期就是它從創建到銷毀的整個過程。生命週期在必要時可以顯式標記。

```rust
fn main() {
    let v = vec![1, 2, 3, 4, 5]; // --> v 的生命週期開始
    {
        let center = v[2];       // --> center 的生命週期開始
        println!("{}", center);
    }                            // <-- center 的生命週期結束
    println!("{:?}", v);
}                                // <-- v 的生命週期結束
```

## 借用\(borrow\)

如果一個變數永遠只能有唯一一個入口可以訪問的話，那就太難使用了。因此，所有權還可以借用。

借用指標的語法使用**&符號\(唯讀\)**或者**&mut符號**\(可讀寫\)表示。前者表示唯讀借用，後者表示可讀寫借用。**借用指標（borrow pointer）也可以稱作“引用”（reference）**。借用指標與普通指標的內部資料是一模一樣的，唯一的區別是語義層面上的。它的作用是告訴編譯器，它對指向的這塊記憶體區域沒有所有權。

```rust
// 我們需要“可變的”借用指標,因此函數簽名需要改變
fn foo(v: &mut Vec<i32>) {
    v.push(5);
}
fn main() {
    // 我們需要這個動態陣列本身是“可變的”,才能獲得它的“可變借用指針”
    let mut v = vec![];
    // 在函式呼叫的時候,同時也要顯示獲取它的“可變借用指針”
    foo(&mut v);
    // 列印結果,可以看到v已經被改變
    println!("{:?}", v);
}
```

對於&mut型指針，要注意不要混淆它與變數綁定之間的語法。

* 如果mut修飾的是變數名，那麼它代表這個變數可以被重新綁定；\(但指向的物件不能被修改\)
* 如果mut修飾的是“借用指標&”，那麼它代表的是被指向的物件可以被修改。\(但變數不能被修改\)

## 借用規則

* 借用指標不能比它指向的變數存在的時間更長。
  * **借用指標只能臨時地擁有對這個變數讀或寫的許可權，沒有義務管理這個變數的生命週期。**因此，借用指標的生命週期絕對不能大於它所引用的原來變數的生命週期，否則就是懸空指標，會導致記憶體不安全。
* `&mut`型借用只能指向本身具有`mut`修飾的變數，對於唯讀變數，不可以有`&mut`型借用。
* `&mut`型借用指標存在的時候，被借用的變數本身會處於“凍結”狀態，即被借用的變數不可被存取。
* \[共享不可變\] 如果只有`&`型借用指針，那麼能同時存在多個；

  * \[可變不共享\] 如果存在`&mut`型借用指標，那麼只能存在一個；
  * 如果同時有其他的`&`或者`&mut`型借用指針存在，那麼會出現編譯錯誤。

```rust
// 參數採用的“引用傳遞”,因此參數本身並未丟失對記憶體的管理權
fn borrow_semantics(v: &Vec<i32>) {
    // 列印參數佔用空間的大小,在64位元系統上,結果為8,
    // 表明該指針與普通裸指針的內部表示方法相同
    println!("size of param: {}", std::mem::size_of::<&Vec<i32>>());
    for item in v {
        print!("{} ", item);
    }
    println!("");
}
// 這裡的參數採用的“值傳遞”,
// 而Vec沒有實現Copy trait,意味著它將執行move語義
fn move_semantics(v: Vec<i32>) {
    // 列印參數佔用空間的大小,結果為24,
    // 表明參數中堆疊上分配的記憶體空間複製到了函數的參數中
    println!("size of param: {}", std::mem::size_of::<Vec<i32>>());
    for item in v {
        print!("{} ", item);
    }
    println!("");
}
fn main() {
    let array = vec![1, 2, 3];
    // 如果使用引用傳遞,不僅在函式宣告的地方需要使用&標記
    // 函式呼叫的地方同樣需要使用&標記,否則會出現語法錯誤
    // 這樣設計主要是為了顯眼,不用去閱讀該函數的簽名就知道這個函式呼叫的時候發生了什麼
    // 而小數點方式的成員函式呼叫,對於self參數,會“自動轉換”,不必顯式借用,這裡有個區別
    borrow_semantics(&array);
    // 在使用引用傳遞給上面的函數後,array本身依然有效,我們還能在下面的函數中使用
    move_semantics(array);
    // 在使用move語義傳遞後,array在這個函式呼叫後,它的生命週期已經完結
}
```

```rust
fn main() {
    let mut x = 1_i32;
    let p = &mut x;
    // 任何借用指標的存在，都會導致原來的變數被“凍結”（Frozen）。
    // 因此x不可再被存取
    x = 2; // compile error
    println!("value of pointed : {}", p);
}
```



## 參考資料

* [\[知乎\] 理解 Rust 引用和借用](https://zhuanlan.zhihu.com/p/59998584)

