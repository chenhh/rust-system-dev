# panic

## 簡介

在Rust中，有一類錯誤叫作panic。

```rust
fn main() {
    let x: Option<i32> = None;
    // 無法由None取出資料, 產生panic
    x.unwrap();
}
```

在Rust中，正常的錯誤處理應該儘量使用Result類型。Panic則是作為一種“fail fast”機制，處理那種萬不得已的情況。

比如，上面例子中的unwrap方法，試圖把Option\<i32>轉換為i32類型，當參數是None的時候，這個轉換是沒辦法做到的，這種時候就只能使用panic。所以，一般情況下，使用者應該使用unwrap\_or等不會製造panic的方法。

panic並不意味著“記憶體不安全”，恰恰相反，它是阻止“記憶體不安全”的利器。記憶體不安全造成的問題比程式突然退出要嚴重得多。在即將發生記憶體不安全現象的時候，如果當時已經沒有任何其他選擇，panic至少可以避免最壞情況的發生。然後我們可以很快發現事故的第一現場，從而修復程式碼，使其繼續執行。

## panic實現機制

在Rust中，Panic的實現機制有兩種方式：unwind和abort，依作業系統或是使用者自行選擇而定。

* unwind方式在發生panic的時候，會一層一層地退出函式呼叫堆疊，在此過程中，當前堆疊內的區域變數還可以正常解構。
* abort方式在發生panic的時候，會直接退出整個程式。

**在常見的作業系統上，預設情況下，編譯器使用的是unwind方式**。所以在發生panic的時候，我們可以通過一層層地調用堆疊找到發生panic的第一現場。

但是，unwind並不是在所有平臺上都能獲得良好支持的。在某些嵌入式系統上，unwind根本無法實現，或者佔用的資源太多。在這種時候，我們可以選擇使用abort方式實現panic。

### 對應 panic 時的堆疊展開或終止

編譯器提供了一個選項，供使用者指定panic的實現方式：

```bash
rustc -C panic=unwind test.rs
rustc -C panic=abort test.rs
```

panic中有catch\_unwind機制絕對不是設計用於模擬“try-catch”機制的。請大家永遠不要利用這個機制來做正常的流程控制。R**ust推薦的錯誤處理機制是用返回值**。

如果你需要項目的最終二進制檔案越小越好，panic 時通過在 Cargo.toml 的 \[profile] 部分增加 panic = 'abort'，可以由展開切換為終止。

```rust
[profile.release]
panic = 'abort'
```

## panic使用時機

**panic出現的場景一般是：如果繼續執行下去就會有極其嚴重的記憶體安全問題，這種時候讓程式繼續執行導致的危害比崩潰更嚴重**，此時panic就是最後的一種錯誤處理機制。

它的主要用處參考下面的情況：

* 在FFI場景下的時候，當C語言調用了Rust的函數，在Rust內部出現了panic，如果這個panic在Rust內部沒有處理好，直接扔到C程式碼中去，會導致C語言產生“未定義行為”（undefined behavior）。
* 某些高級抽象機制需要阻止堆疊展開，比如執行緒池。如果一個執行緒中出現了panic，我們希望只把這個執行緒關閉，而不至於將整個執行緒池“拖下水”。

## panic safety

C++中引入了“異常”這個機制之後，同時也帶入了一個“異常安全”（exception safety）的概念。

異常安全存在四種層次的保證：

* No-throw：這種層次的安全性保證了所有的異常都在內部正確處理完畢，外部毫無影響；
* Strong exception safety：強異常安全保證可以保證異常發生的時候，所有的狀態都可以“回滾”到初始狀態，不會導致狀態不一致的問題；
* Basic exception safety：基本異常安全保證可以保證異常發生的時候不會導致資源洩漏；
* No exception safety：沒有任何異常安全保證。

當我們在系統中使用了“異常”的時候，就一定要想清楚，每個元件應該提供哪種層級的異常安全保證。**在Rust中，這個問題同樣存在，但是一般叫作panic safety，與“異常”說的是同一件事情**。

**Rust的標準庫在編寫的時候有這樣一個目標：即便發生了panic，也不會產生“記憶體不安全”和“執行緒不安全”的情況**。

在Rust中，什麼情況下panic會導致bug呢？這種情況的產生需要兩個條件同時發生：

* panic導致了資料結構內部的狀態錯誤；
* 這個錯誤的狀態會在以後被觀測到。

在unsafe程式碼中，這種情況非常容易出現。所以，在寫unsafe程式碼的時候，需要對這種情況非常敏感小心，一不小心就可能因為這個原因製造出“記憶體不安全”。

在不用unsafe的情況下，Panic Safety是基本有保障的。

考慮一種場景、假如我們有兩個資料結構，我們希望每次在更新其中一個的時候，也要對另外一個同步更新，如果不一致就會有問題。萬一更新了其中一個，發生了panic，第二個沒有正常更新怎麼處理?

```rust
use std::panic;
fn main() {
    let mut x: Vec<i32> = vec![1];
    let mut y: Vec<i32> = vec![2];
    /* 這裡我們必須使用catch_unwind來阻止堆疊展開，
       否則這兩個資料結構就一起被銷毀了，
       無法觀測到panic引發的錯誤狀態。
    */
    panic::catch_unwind(|| {
        x.push(10);
        panic!("user panic");
        // 這段程式碼是無法編譯通過
        y.push(100);
    })
    .ok();
    println!("Observe corruptted data. {:?} {:?}", x, y);
}
```

這段程式碼是無法編譯通過的，因為catch\_unwind的簽名它要求閉包參數滿足UnwindSafe條件，而標準庫中早就標記好了\&mut型指標是不滿足UnwindSafe trait的。有些類型，天生就不適合在catch\_unwind的外部和內部同時存在。

有了這個約束條件，被panic破壞掉的資料結構被外部繼續觀測、使用的幾率就小了許多。

當然，編譯器是永遠不知道用戶的真實意圖的，可能在某些場景下，用戶就是要這樣寫，而且不認為這些資料結構是“被破壞”的狀態。怎麼修復上面這個編譯錯誤呢？

我們可以用AssertUnwindSafe把這個閉包包一層，就可以強制突破編譯器的限制了。我們也可以單獨為某個變數來包一層，可以起到一樣的效果。AssertUnwindSafe這個類型，不管內部包含的是什麼資料，它都是滿足catch\_unwind函數約束的。**這個設計至少能保證catch\_unwind可能造成的風險是顯式標記出來的**。

